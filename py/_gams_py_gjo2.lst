GAMS 46.2.0  ac4adda6 Mar 5, 2024           WEX-WEI x86 64bit/MS Windows - 05/09/24 15:17:03 Page 1
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
C o m p i l a t i o n


   3   
   4   
   5   
   6  ;
   7  OPTION SYSOUT=OFF, SOLPRINT=OFF, LIMROW=0, LIMCOL=0, DECIMALS=6;
   8   
   9   
  10  # User defined functions:
  11   
  12  # ----------------------------------------------------------------------------------------------------
  13  #  Define function: SolveEmptyNLP
  14  # ----------------------------------------------------------------------------------------------------
  15   
  16   
  17  sets
  18          alias_set
  19          alias_map2
  20          n
  21          s
  22          t
  23          taxTypes
  24  ;
  25   
  26  alias(n,nn,nnn);
  27  alias(s,ss);
  28   
  29  sets
  30          alias_[alias_set,alias_map2]
  31          P_map[s,n,nn]
  32          P_map_spinp[s,n,nn]
  33          P_map_spout[s,n,nn]
  34          P_knout[s,n]
  35          P_kninp[s,n]
  36          P_spout[s,n]
  37          P_spinp[s,n]
  38          P_input[s,n]
  39          P_output[s,n]
  40          P_int[s,n]
  41          W_map[s,n,nn]
  42          W_knot[s,n]
  43          W_branch[s,n]
  44          W_knot_o[s,n]
  45          W_knot_no[s,n]
  46          W_branch2o[s,n]
  47          W_branch2no[s,n]
  48          O_map[s,n,nn]
  49          O_knot[s,n]
  50          O_branch[s,n]
  51          O_knot_o[s,n]
  52          O_knot_no[s,n]
  53          O_branch2o[s,n]
  54          O_branch2no[s,n]
  55          P_sm[s]
  56          P_output_n[n]
  57          P_input_n[n]
  58          P_endoMu[s,n,nn]
  59          s_p[s]
  60          n_p[n]
  61          n_F[n]
  62          s_HH[s]
  63          s_G[s]
  64          s_i[s]
  65          s_f[s]
  66          dur_p[n]
  67          inv_p[n]
  68          dur2inv[n,nn]
  69          nEqui[n]
  70          d_qS[s,n]
  71          d_qD[s,n]
  72          d_qSEqui[s,n]
  73          d_pEqui[n]
  74          dom2for[n,nn]
  75          dExport[s,n]
  76          dImport[s,n,nn]
  77          dImport_dom[s,n]
  78          dImport_for[s,n]
  79          t0[t]
  80          tx0[t]
  81          tE[t]
  82          t2E[t]
  83          txE[t]
  84          tx2E[t]
  85          tx0E[t]
  86          tx02E[t]
  87          nestProduction[s,n,nn]
  88          dtauCO2[t,s,n]
  89          dqCO2[t,s,n]
  90          nestInvestment[s,n,nn]
  91          nestHH[s,n,nn]
  92          L2C[s,n,nn]
  93          nestG[s,n,nn]
  94          d_TotalTax[t,s]
  95          P_dur[s,n]
  96          P_dur2inv[s,n,nn]
  97          P_inv[s,n]
  98  ;
  99   
 100  parameters
 101          R_LR
 102          infl_LR
 103          g_LR
 104  ;
 105   
 106  variables
 107          vTax[t,s,taxTypes]
 108          TotalTax[t,s]
 109          vD[t,s,n]
 110          vD_dur[t,s,n]
 111          vD_depr[t,s,n]
 112          vD_inv[t,s,n]
 113          qCO2[t,s,n]
 114          rDepr[t,s,n]
 115          vS[t,s,n]
 116          p[t,n]
 117          qD[t,s,n]
 118          pD_dur[t,s,n]
 119          qS[t,s,n]
 120          sigma[s,n]
 121          tauCO2[t,s,n]
 122          tauS[t,s,n]
 123          tauD[t,s,n]
 124          tauLump[t,s]
 125          tauNonEnv[t,s,n]
 126          tauNonEnv0[t,s,n]
 127          pD[t,s,n]
 128          Rrate[t]
 129          mu[s,n,nn]
 130          pS[t,s,n]
 131          adjCostPar[s,n]
 132          K_tvc[s,n]
 133          adjCost[t,s]
 134          markup[s]
 135          taxRevPar[s]
 136  ;
GDXIN   C:\Users\sxj477\Documents\GitHub\CGE_Generator\py\P.gdx
--- LOAD  alias_set = 2:alias_set
--- LOAD  alias_map2 = 3:alias_map2
--- LOAD  n = 4:n
--- LOAD  s = 5:s
--- LOAD  t = 48:t
--- LOAD  taxTypes = 49:taxTypes
--- LOAD  alias_ = 1:alias_
--- LOAD  P_map = 6:P_map
--- LOAD  P_map_spinp = 7:P_map_spinp
--- LOAD  P_map_spout = 8:P_map_spout
--- LOAD  P_knout = 9:P_knout
--- LOAD  P_kninp = 10:P_kninp
--- LOAD  P_spout = 11:P_spout
--- LOAD  P_spinp = 12:P_spinp
--- LOAD  P_input = 13:P_input
--- LOAD  P_output = 14:P_output
--- LOAD  P_int = 15:P_int
--- LOAD  W_map = 16:W_map
--- LOAD  W_knot = 17:W_knot
--- LOAD  W_branch = 18:W_branch
--- LOAD  W_knot_o = 19:W_knot_o
--- LOAD  W_knot_no = 20:W_knot_no
--- LOAD  W_branch2o = 21:W_branch2o
--- LOAD  W_branch2no = 22:W_branch2no
--- LOAD  O_map = 23:O_map
--- LOAD  O_knot = 24:O_knot
--- LOAD  O_branch = 25:O_branch
--- LOAD  O_knot_o = 26:O_knot_o
--- LOAD  O_knot_no = 27:O_knot_no
--- LOAD  O_branch2o = 28:O_branch2o
--- LOAD  O_branch2no = 29:O_branch2no
--- LOAD  P_sm = 30:P_sm
--- LOAD  P_output_n = 31:P_output_n
--- LOAD  P_input_n = 32:P_input_n
--- LOAD  P_endoMu = 33:P_endoMu
--- LOAD  s_p = 41:s_p
--- LOAD  n_p = 42:n_p
--- LOAD  n_F = 43:n_F
--- LOAD  s_HH = 44:s_HH
--- LOAD  s_G = 45:s_G
--- LOAD  s_i = 46:s_i
--- LOAD  s_f = 47:s_f
--- LOAD  dur_p = 51:dur_p
--- LOAD  inv_p = 52:inv_p
--- LOAD  dur2inv = 53:dur2inv
--- LOAD  nEqui = 62:nEqui
--- LOAD  d_qS = 63:d_qS
--- LOAD  d_qD = 64:d_qD
--- LOAD  d_qSEqui = 65:d_qSEqui
--- LOAD  d_pEqui = 66:d_pEqui
--- LOAD  dom2for = 67:dom2for
--- LOAD  dExport = 68:dExport
--- LOAD  dImport = 69:dImport
--- LOAD  dImport_dom = 70:dImport_dom
--- LOAD  dImport_for = 71:dImport_for
--- LOAD  t0 = 72:t0
--- LOAD  tx0 = 73:tx0
--- LOAD  tE = 74:tE
--- LOAD  t2E = 75:t2E
--- LOAD  txE = 76:txE
--- LOAD  tx2E = 77:tx2E
--- LOAD  tx0E = 78:tx0E
--- LOAD  tx02E = 79:tx02E
--- LOAD  nestProduction = 80:nestProduction
--- LOAD  dtauCO2 = 83:dtauCO2
--- LOAD  dqCO2 = 84:dqCO2
--- LOAD  nestInvestment = 91:nestInvestment
--- LOAD  nestHH = 92:nestHH
--- LOAD  L2C = 93:L2C
--- LOAD  nestG = 94:nestG
--- LOAD  d_TotalTax = 95:d_TotalTax
--- LOAD  P_dur = 98:P_dur
--- LOAD  P_dur2inv = 99:P_dur2inv
--- LOAD  P_inv = 100:P_inv
GDXIN   C:\Users\sxj477\Documents\GitHub\CGE_Generator\py\P.gdx
--- LOAD  R_LR = 54:R_LR
--- LOAD  infl_LR = 55:infl_LR
--- LOAD  g_LR = 56:g_LR
GDXIN   C:\Users\sxj477\Documents\GitHub\CGE_Generator\py\P.gdx
--- LOAD  vTax = 34:vTax
--- LOAD  TotalTax = 35:TotalTax
--- LOAD  vD = 36:vD
--- LOAD  vD_dur = 37:vD_dur
--- LOAD  vD_depr = 38:vD_depr
--- LOAD  vD_inv = 39:vD_inv
--- LOAD  qCO2 = 40:qCO2
--- LOAD  rDepr = 50:rDepr
--- LOAD  vS = 57:vS
--- LOAD  p = 58:p
--- LOAD  qD = 59:qD
--- LOAD  pD_dur = 60:pD_dur
--- LOAD  qS = 61:qS
--- LOAD  sigma = 81:sigma
--- LOAD  tauCO2 = 82:tauCO2
--- LOAD  tauS = 85:tauS
--- LOAD  tauD = 86:tauD
--- LOAD  tauLump = 87:tauLump
--- LOAD  tauNonEnv = 88:tauNonEnv
--- LOAD  tauNonEnv0 = 89:tauNonEnv0
--- LOAD  pD = 90:pD
--- LOAD  Rrate = 96:Rrate
--- LOAD  mu = 97:mu
--- LOAD  pS = 101:pS
--- LOAD  adjCostPar = 102:adjCostPar
--- LOAD  K_tvc = 103:K_tvc
--- LOAD  adjCost = 104:adjCost
--- LOAD  markup = 105:markup
--- LOAD  taxRevPar = 106:taxRevPar
 255   
 256   
 257   
 258   
 259   
 260  # -------------------------------------------------B_W------------------------------------------------
 261  #  Initialize B_W equation block
 262  # ----------------------------------------------------------------------------------------------------
 263  EQUATION E_W_zpOut[t,s,n];
 264  E_W_zpOut[t,s,n]$(w_knot_o[s,n] and txe[t])..   pS[t,s,n]*qS[t,s,n]  =E=  sum(nn$(W_map[s,n,nn]), qD[t,s,nn]*pD[t,s,nn]);
 265  EQUATION E_W_zpNOut[t,s,n];
 266  E_W_zpNOut[t,s,n]$(w_knot_no[s,n] and txe[t])..         pD[t,s,n]*qD[t,s,n]  =E=  sum(nn$(W_map[s,n,nn]), qD[t,s,nn]*pD[t,s,nn]);
 267  EQUATION E_W_qOut[t,s,n];
 268  E_W_qOut[t,s,n]$(w_branch2o[s,n] and txe[t])..  qD[t,s,n]  =E=  sum(nn$(W_map[s,nn,n]), mu[s,nn,n] * (pS[t,s,nn]/pD[t,s,n])**(sigma[s,nn]) * qS[t,s,nn]);
 269  EQUATION E_W_qNOut[t,s,n];
 270  E_W_qNOut[t,s,n]$(w_branch2no[s,n] and txe[t])..        qD[t,s,n]  =E=  sum(nn$(W_map[s,nn,n]), mu[s,nn,n] * (pD[t,s,nn]/pD[t,s,n])**(sigma[s,nn]) * qD[t,s,nn]);
 271   
 272  # ----------------------------------------------------------------------------------------------------
 273  #  Define B_W model
 274  # ----------------------------------------------------------------------------------------------------
 275  Model B_W /
 276  E_W_zpOut, E_W_zpNOut, E_W_qOut, E_W_qNOut
 277  /;
 278   
 279   
 280   
 281  # -------------------------------------------------B_O------------------------------------------------
 282  #  Initialize B_O equation block
 283  # ----------------------------------------------------------------------------------------------------
 284  EQUATION E_O_zpOut[t,s,n];
 285  E_O_zpOut[t,s,n]$(o_knot_o[s,n] and txe[t])..   pS[t,s,n]*qS[t,s,n]  =E=  sum(nn$(O_map[s,n,nn]), qD[t,s,nn]*pD[t,s,nn]);
 286  EQUATION E_O_zpNOut[t,s,n];
 287  E_O_zpNOut[t,s,n]$(o_knot_no[s,n] and txe[t])..         pD[t,s,n]*qD[t,s,n]  =E=  sum(nn$(O_map[s,n,nn]), qD[t,s,nn]*pD[t,s,nn]);
 288  EQUATION E_O_qOut[t,s,n];
 289  E_O_qOut[t,s,n]$(o_branch2o[s,n] and txe[t])..  qD[t,s,n]  =E=  sum(nn$(O_map[s,nn,n]), mu[s,nn,n] * (pS[t,s,nn]/pD[t,s,n])**(sigma[s,nn]) * qS[t,s,nn]);
 290  EQUATION E_O_qNOut[t,s,n];
 291  E_O_qNOut[t,s,n]$(o_branch2no[s,n] and txe[t])..        qD[t,s,n]  =E=  sum(nn$(O_map[s,nn,n]), mu[s,nn,n] * (pD[t,s,nn]/pD[t,s,n])**(sigma[s,nn]) * qD[t,s,nn]);
 292   
 293  # ----------------------------------------------------------------------------------------------------
 294  #  Define B_O model
 295  # ----------------------------------------------------------------------------------------------------
 296  Model B_O /
 297  E_O_zpOut, E_O_zpNOut, E_O_qOut, E_O_qNOut
 298  /;
 299   
 300   
 301   
 302  # ---------------------------------------------B_P_adjCost--------------------------------------------
 303  #  Initialize B_P_adjCost equation block
 304  # ----------------------------------------------------------------------------------------------------
 305  EQUATION E_P_adjCost_lom[t,s,n];
 306  E_P_adjCost_lom[t,s,n]$(p_dur[s,n] and txe[t])..                qD[t+1,s,n]      =E=  (qD[t,s,n]*(1-rDepr[t,s,n])+sum(nn$(P_dur2inv[s,n,nn]), qD[t,s,nn]))/(1+g_LR);
 307  EQUATION E_P_adjCost_pk[t,s,n];
 308  E_P_adjCost_pk[t,s,n]$(p_dur[s,n] and tx02e[t])..       pD[t,s,n]        =E=  sqrt(sqr(sum(nn$(P_dur2inv[s,n,nn]), Rrate[t]*pD[t-1,s,nn]*(1+adjCostPar[s,n]*(qD[t-1,s,nn]/qD[t-1,s,n]-(rDepr[t-1,s,n]+g_LR)))/(1+infl_LR)+pD[t,s,nn]*(adjCostPar[s,n]*0.5*(sqr(rDepr[t,s,n]+g_LR)-sqr(qD[t,s,nn]/qD[t,s,n]))-(1-rDepr[t,s,n])*(1+adjCostPar[s,n]*(qD[t,s,nn]/qD[t,s,n]-(rDepr[t,s,n]+g_LR)))))));
 309  EQUATION E_P_adjCost_pkT[t,s,n];
 310  E_P_adjCost_pkT[t,s,n]$(p_dur[s,n] and t2e[t])..                pD[t,s,n]        =E=  sum(nn$(P_dur2inv[s,n,nn]), Rrate[t]*pD[t-1,s,nn] * (1+adjCostPar[s,n]*(qD[t-1,s,nn]/qD[t-1,s,n]-(rDepr[t-1,s,n]+g_LR)))/(1+infl_LR) + (rDepr[t,s,n]-1)*pD[t,s,nn]);
 311  EQUATION E_P_adjCost_K_tvc[t,s,n];
 312  E_P_adjCost_K_tvc[t,s,n]$(p_dur[s,n] and te[t])..       qD[t,s,n]        =E=  (1+K_tvc[s,n])*qD[t-1,s,n];
 313  EQUATION E_P_adjCost_adjCost[t,s];
 314  E_P_adjCost_adjCost[t,s]$(p_sm[s] and txe[t])..                 adjCost[t,s]     =E=  sum([n,nn]$(P_dur2inv[s,n,nn]), pD[t,s,nn] * adjCostPar[s,n]*0.5*qD[t,s,n]*sqr(qD[t,s,nn]/qD[t,s,n]-(rDepr[t,s,n]+g_LR)));
 315   
 316  # ----------------------------------------------------------------------------------------------------
 317  #  Define B_P_adjCost model
 318  # ----------------------------------------------------------------------------------------------------
 319  Model B_P_adjCost /
 320  E_P_adjCost_lom, E_P_adjCost_pk, E_P_adjCost_pkT, E_P_adjCost_K_tvc, E_P_adjCost_adjCost
 321  /;
 322   
 323   
 324   
 325  # ---------------------------------------------B_P_pWedge---------------------------------------------
 326  #  Initialize B_P_pWedge equation block
 327  # ----------------------------------------------------------------------------------------------------
 328  EQUATION E_P_pWedge_pwInp[t,s,n];
 329  E_P_pWedge_pwInp[t,s,n]$(p_input[s,n] and txe[t])..                     pD[t,s,n]                =E=  p[t,n]+tauD[t,s,n];
 330  EQUATION E_P_pWedge_pwOut[t,s,n];
 331  E_P_pWedge_pwOut[t,s,n]$(p_output[s,n] and txe[t])..            p[t,n]                   =E=  (1+markup[s])*(pS[t,s,n]+tauS[t,s,n]+(adjCost[t,s]+tauLump[t,s])/qS[t,s,n]);
 332  EQUATION E_P_pWedge_taxRev[t,s];
 333  E_P_pWedge_taxRev[t,s]$(s_p[s] and txe[t])..                            TotalTax[t,s]    =E=  tauLump[t,s]+sum(n$(P_input[s,n]), tauD[t,s,n] * qD[t,s,n])+sum(n$(P_output[s,n]), tauS[t,s,n]*qS[t,s,n]);
 334  EQUATION E_P_pWedge_tauS[t,s,n];
 335  E_P_pWedge_tauS[t,s,n]$(p_output[s,n] and txe[t])..                     tauS[t,s,n]              =E=  tauCO2[t,s,n] * qCO2[t,s,n]/qS[t,s,n]+tauNonEnv[t,s,n];
 336   
 337  # ----------------------------------------------------------------------------------------------------
 338  #  Define B_P_pWedge model
 339  # ----------------------------------------------------------------------------------------------------
 340  Model B_P_pWedge /
 341  E_P_pWedge_pwInp, E_P_pWedge_pwOut, E_P_pWedge_taxRev, E_P_pWedge_tauS
 342  /;
 343   
 344   
 345   
 346  # --------------------------------------------B_P_taxCalib--------------------------------------------
 347  #  Initialize B_P_taxCalib equation block
 348  # ----------------------------------------------------------------------------------------------------
 349  EQUATION E_P_taxCalib_taxCal[t,s,n];
 350  E_P_taxCalib_taxCal[t,s,n]$(p_output[s,n] and txe[t])..         tauNonEnv[t,s,n]         =E=  tauNonEnv0[t,s,n] * (1+taxRevPar[s]);
 351   
 352  # ----------------------------------------------------------------------------------------------------
 353  #  Define B_P_taxCalib model
 354  # ----------------------------------------------------------------------------------------------------
 355  Model B_P_taxCalib /
 356  E_P_taxCalib_taxCal
 357  /;
 358   
 359   
 360   
 361  # ----------------------------------------------------------------------------------------------------
 362  #  Define P_B model
 363  # ----------------------------------------------------------------------------------------------------
 364  Model P_B /
 365  E_W_zpOut, E_W_zpNOut, E_W_qOut, E_W_qNOut, E_O_zpOut, E_O_zpNOut, E_O_qOut, E_O_qNOut, E_P_adjCost_lom, E_P_adjCost_pk, E_P_adjCost_pkT, E_P_adjCost_K_tvc, E_P_adjCost_adjCost, E_P_pWedge_pwInp, E_P_pWedge_pwOut, E_P_pWedge_taxRev, E_P_pWedge_tauS
 366  /;
 367   
 368   
 369  # ----------------------------------------------------------------------------------------------------
 370  #  Define P_C model
 371  # ----------------------------------------------------------------------------------------------------
 372  Model P_C /
 373  E_W_zpOut, E_W_zpNOut, E_W_qOut, E_W_qNOut, E_O_zpOut, E_O_zpNOut, E_O_qOut, E_O_qNOut, E_P_adjCost_lom, E_P_adjCost_pk, E_P_adjCost_pkT, E_P_adjCost_K_tvc, E_P_adjCost_adjCost, E_P_pWedge_pwInp, E_P_pWedge_pwOut, E_P_pWedge_taxRev, E_P_pWedge_tauS, E_P_taxCalib_taxCal
 374  /;
 375   
 376   
 377  # Fix exogenous variables in state B:
 378  qS.fx[t,s,n]$(P_output[s,n]) = qS.l[t,s,n]$(P_output[s,n]);
 379  sigma.fx[s,n]$(P_kninp[s,n]) = sigma.l[s,n]$(P_kninp[s,n]);
 380  mu.fx[s,n,nn]$(((P_map[s,n,nn] and ( not (P_endoMu[s,n,nn]))) or P_endoMu[s,n,nn])) = mu.l[s,n,nn]$(((P_map[s,n,nn] and ( not (P_endoMu[s,n,nn]))) or P_endoMu[s,n,nn]));
 381  tauNonEnv0.fx[t,s,n]$(P_output[s,n]) = tauNonEnv0.l[t,s,n]$(P_output[s,n]);
 382  tauD.fx[t,s,n]$(P_input[s,n]) = tauD.l[t,s,n]$(P_input[s,n]);
 383  tauLump.fx[t,s]$(P_sm[s]) = tauLump.l[t,s]$(P_sm[s]);
 384  p.fx[t,n]$((P_input_n[n] and ( not (P_output_n[n])))) = p.l[t,n]$((P_input_n[n] and ( not (P_output_n[n]))));
 385  qCO2.fx[t,s,n]$(P_output[s,n]) = qCO2.l[t,s,n]$(P_output[s,n]);
 386  tauCO2.fx[t,s,n]$(P_output[s,n]) = tauCO2.l[t,s,n]$(P_output[s,n]);
 387  Rrate.fx[t] = Rrate.l[t];
 388  rDepr.fx[t,s,n]$(P_dur[s,n]) = rDepr.l[t,s,n]$(P_dur[s,n]);
 389  adjCostPar.fx[s,n]$(P_dur[s,n]) = adjCostPar.l[s,n]$(P_dur[s,n]);
 390  K_tvc.fx[s,n]$(P_dur[s,n]) = K_tvc.l[s,n]$(P_dur[s,n]);
 391  qD.fx[t,s,n]$((P_dur[s,n] and t0[t])) = qD.l[t,s,n]$((P_dur[s,n] and t0[t]));
 392  tauNonEnv.fx[t,s,n]$(P_output[s,n]) = tauNonEnv.l[t,s,n]$(P_output[s,n]);
 393  taxRevPar.fx[s]$(P_sm[s]) = taxRevPar.l[s]$(P_sm[s]);
 394  markup.fx[s]$(P_sm[s]) = markup.l[s]$(P_sm[s]);
 395   
 396  # Unfix endogenous variables in state B:
 397  pD.lo[t,s,n]$((P_int[s,n] or P_input[s,n] or (P_dur[s,n] and txE[t]))) = -inf;
 398  pD.up[t,s,n]$((P_int[s,n] or P_input[s,n] or (P_dur[s,n] and txE[t]))) = inf;
 399  pS.lo[t,s,n]$(P_output[s,n]) = -inf;
 400  pS.up[t,s,n]$(P_output[s,n]) = inf;
 401  p.lo[t,n]$(((P_output_n[n] and tx0[t]) or (P_output_n[n] and t0[t]))) = -inf;
 402  p.up[t,n]$(((P_output_n[n] and tx0[t]) or (P_output_n[n] and t0[t]))) = inf;
 403  qD.lo[t,s,n]$(((P_int[s,n] or (P_input[s,n] and tx0[t]) or (P_dur[s,n] and tx0[t])) or (P_input[s,n] and t0[t]))) = -inf;
 404  qD.up[t,s,n]$(((P_int[s,n] or (P_input[s,n] and tx0[t]) or (P_dur[s,n] and tx0[t])) or (P_input[s,n] and t0[t]))) = inf;
 405  adjCost.lo[t,s]$((P_sm[s] and txE[t])) = -inf;
 406  adjCost.up[t,s]$((P_sm[s] and txE[t])) = inf;
 407  tauS.lo[t,s,n]$(P_output[s,n]) = -inf;
 408  tauS.up[t,s,n]$(P_output[s,n]) = inf;
 409  TotalTax.lo[t,s]$(((P_sm[s] and tx0E[t]) or (P_sm[s] and t0[t]))) = -inf;
 410  TotalTax.up[t,s]$(((P_sm[s] and tx0E[t]) or (P_sm[s] and t0[t]))) = inf;
 411   
 412  solve P_B using CNS;
GAMS 46.2.0  ac4adda6 Mar 5, 2024           WEX-WEI x86 64bit/MS Windows - 05/09/24 15:17:03 Page 2
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Include File Summary


   SEQ   GLOBAL TYPE      PARENT   LOCAL  FILENAME

     1        1 INPUT          0       0  C:\Users\sxj477\Documents\GitHub\CGE_Generator\py\_gams_py_gjo2.gms
     2      137 GDXIN          1     137  C:\Users\sxj477\Documents\GitHub\CGE_Generator\py\P.gdx
     3      215 GDXIN          1     215  C:\Users\sxj477\Documents\GitHub\CGE_Generator\py\P.gdx
     4      222 GDXIN          1     222  C:\Users\sxj477\Documents\GitHub\CGE_Generator\py\P.gdx


COMPILATION TIME     =        0.032 SECONDS      6 MB  46.2.0 ac4adda6 WEX-WEI
GAMS 46.2.0  ac4adda6 Mar 5, 2024           WEX-WEI x86 64bit/MS Windows - 05/09/24 15:17:03 Page 3
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE P_B Using CNS From line 412


MODEL STATISTICS

BLOCKS OF EQUATIONS          17     SINGLE EQUATIONS       17,700
BLOCKS OF VARIABLES          20     SINGLE VARIABLES       25,823
NON ZERO ELEMENTS       103,350     NON LINEAR N-Z         78,850
CODE LENGTH             161,121     CONSTANT POOL              20
SINGLE =E|X= EQUS        17,700     SINGLE UNFIXED VARS    17,700


GENERATION TIME      =        0.078 SECONDS     16 MB  46.2.0 ac4adda6 WEX-WEI
GAMS 46.2.0  ac4adda6 Mar 5, 2024           WEX-WEI x86 64bit/MS Windows - 05/09/24 15:17:03 Page 4
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE P_B Using CNS From line 412


               S O L V E      S U M M A R Y

     MODEL   P_B                 
     TYPE    CNS                 
     SOLVER  CONOPT              FROM LINE  412

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      16 Solved

 RESOURCE USAGE, LIMIT          0.094 10000000000.000
 ITERATION COUNT, LIMIT         1    2147483647
 EVALUATION ERRORS              0             0
 
 
    C O N O P T   version 4.33
    Copyright (C) ARKI Consulting and Development A/S
                  Bagsvaerdvej 246 A
                  DK-2880 Bagsvaerd, Denmark
 
    Will use up to 8 threads.
 
 
    The user model has 17700 constraints and 25823 variables
    with 103350 Jacobian elements, 78850 of which are nonlinear.
 
    The pre-triangular part of the model has 2800 constraints and 10923 variables.
    The post-triangular part of the model has 500 constraints and variables.
 
    Preprocessed model has 14400 constraints and 14400 variables
    with 55050 Jacobian elements, 41455 of which are nonlinear.
 
 ** Feasible solution to a square system.
 
 
 CONOPT time Total                            0.089 seconds
   of which: Function evaluations             0.003 =  3.4%
             1st Derivative evaluations       0.002 =  2.2%
 


**** REPORT SUMMARY :        0 INFEASIBLE
                             0  DEPENDENT
                             0     ERRORS


EXECUTION TIME       =        0.328 SECONDS     16 MB  46.2.0 ac4adda6 WEX-WEI


USER: Medium MUD - 10 User License                   G231024|0002AP-WIN
      University of Copenhagen, Department of Economics           DC203
      License for teaching and research at degree granting institutions


**** FILE SUMMARY

Input      C:\Users\sxj477\Documents\GitHub\CGE_Generator\py\_gams_py_gjo2.gms
Output     C:\Users\sxj477\Documents\GitHub\CGE_Generator\py\_gams_py_gjo2.lst
